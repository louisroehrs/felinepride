schema {
    query: QueryType
}


type QueryType {
    user (userName: String email:String): User
    organizationByName (name: String): Organization
    organizationById (id: String): Organization
    orgusers (name:String): OrganizationUsers
    order (orderNumber:String): Order
    customer (lastName:String email:String): Customer
    ordersforproduct (productid: String) : Order
    productsbybrand (brand:String) : [Product]
    customerorders (customerId:String): [Order]
    customersearches (customerId:String): [SearchMetric]
}

type OrganizationUsers {
  organization: Organization
  users: [User]
}

type Attribute {
  name: String
  values: [String]
  type: String
}

type ClassifierClass {
  intent: String
  confidence: Int
}

type Color {
  name: String
  rgb: RGB
}

type ColorDifference {
  c: Color
  diff: Int
}

type ColorResponse {
  status: Int
  message: String
  colors: [OrgColor]
}

type createSearchMetric {

  empty: String
}

type Description {
  display_name: String
  short_description: String
  long_description: String
  thumbnails: [String]
  full_images: [String]
}

type Dimension {
  value: Int
  units: String
}

type Dimensions {
  linearDimensions: LinearDimensions
  volume: Volume
  equivalentDimensions: [LinearDimensions]
}

type DocumentType {
  id: String
  createdDate: String
  createdBy: LoggedUser
  lastModifiedDate: String
  lastModifiedBy: LoggedUser
  documentTypeId: String
  organizationId: String
  instanceId: String
  documentTypeName: String
  documentTypeCode: String
  entity: String
}

type DocumentTypeResponse {
  status: Int
  count: Int
  message: String
  documentTypes: [DocumentType]
}

type EditableGroundTruthObservationResponse {
  status: Int
  count: Int
  message: String
  editableGroundTruthObservations: [GroundTruthObservation]
}

type EntityTag {
  value: String
  weak: Boolean
}

type EventError {
  errorMsg: String
  field: String
}

type EventValidationResponse {
  status: Int
  errorList: [EventError]
  message: String
}

type getAggregationsBySearchTerms {
  
  empty: String
}

type getAggregationsForASearchTerm {
  
  empty: String
}

type getById {
  
  empty: String
}

type getMetricsWithSapphireSolrQuery {
  
  empty: String
}

type getOrgColorByInstanceId {
  
  empty: String
}

type getSchemaMetadataMockup {
  
  empty: String
}

type getSearchEvents {
  
  empty: String
}

type getSearchEventsByTerm {
  
  empty: String
}

type getSearchTerms {
  
  empty: String
}

type GroundTruthObservation {
  id: String
  createdDate: String
  createdBy: LoggedUser
  lastModifiedDate: String
  lastModifiedBy: LoggedUser
  question: String
  title: String
  url: String
  relevanceScore: Int
  documentId: String
  rankerId: String
  entity: String
}

type GroundTruthResponse {
  status: Int
  problems: [String]
  rankerId: String
  added: Int
  ids: [String]
}

input InputStreamInput {
  
  empty: String
}

type Instance {
  id: String
  createdDate: String
  createdBy: LoggedUser
  lastModifiedDate: String
  lastModifiedBy: LoggedUser
  organizationId: String
  searchApiKey: String
  dataApiKey: String
  instanceName: String
  defaultSessionMaxAge: Int
  usingWatson: Boolean
  solrProtocol: String
  solrCollectionName: String
  solrCollectionUrl: String
  solrCollectionSearchUrl: String
  solrClusterId: String
  solrConfigurationName: String
  solrWebUrlBase: String
  solrZkHosts: [String]
  currentRankerId: String
  rankers: [String]
  feeds: [String]
  language: String
  nlcId: String
  sizeCode: String
  username: String
  password: String
  queryModifications: [QueryModification]
  additionalQueryParams: String
  clusterApiUrl: String
  imageUrlBase: String
  preferences: [String]
  scenarios: [String]
  synonyms: [[String]]
  createRequestStatus: String
  entity: String
}

input InstanceInput {
  id: String
  createdDate: String
  createdBy: LoggedUserInput
  lastModifiedDate: String
  lastModifiedBy: LoggedUserInput
  organizationId: String
  searchApiKey: String
  dataApiKey: String
  instanceName: String
  defaultSessionMaxAge: Int
  usingWatson: Boolean
  solrProtocol: String
  solrCollectionName: String
  solrCollectionUrl: String
  solrCollectionSearchUrl: String
  solrClusterId: String
  solrConfigurationName: String
  solrWebUrlBase: String
  solrZkHosts: [String]
  currentRankerId: String
  rankers: [String]
  feeds: [String]
  language: String
  nlcId: String
  sizeCode: String
  username: String
  password: String
  queryModifications: [QueryModificationInput]
  additionalQueryParams: String
  clusterApiUrl: String
  imageUrlBase: String
  preferences: [String]
  scenarios: [String]
  synonyms: [[String]]
  createRequestStatus: String
  entity: String
}

type InstanceResponse {
  status: Int
  count: Int
  message: String
  instances: [Instance]
}

type LinearDimensions {
  length: Dimension
  width: Dimension
  height: Dimension
  dimensions: Int
  round: Int
  by: String
  cube: Boolean
  square: Boolean
  rectangle: Boolean
}

type Link {
  type: String
  params: Link_params
  title: String
  uri: String
  rel: String
  uriBuilder: UriBuilder
  rels: [String]
}

type Link_params {
  
  empty: String
}

type Locale {
  language: String
  script: String
  country: String
  variant: String
  extensionKeys: [String]
  unicodeLocaleAttributes: [String]
  unicodeLocaleKeys: [String]
  iso3Language: String
  iso3Country: String
  displayLanguage: String
  displayScript: String
  displayCountry: String
  displayVariant: String
  displayName: String
}

type LoggedUser {
  id: String
  blueId: String
  userName: String
  firstName: String
  lastName: String
  phoneNumber: String
  email: String
  division: String
  password: String
  name: String
}

input LoggedUserInput {
  id: String
  blueId: String
  userName: String
  firstName: String
  lastName: String
  phoneNumber: String
  email: String
  division: String
  password: String
  name: String
}

type MediaType {
  type: String
  subtype: String
  parameters: MediaType_parameters
  wildcardType: Boolean
  wildcardSubtype: Boolean
}

type MediaType_parameters {
  
  empty: String
}

type Medium {
  mimeType: String
  origin: String
  id: String
  docId: String
  brand: String
  document_type: String
  url: String
  description: Description
  media: [Medium]
  prices: [Price]
  keywords: [String]
  attributes: [Attribute]
  category: [String]
  content: String
  language: String
  location: [String]
}

type Mutation {
  articleDocumentUpload(Authorization: String, body: InputStreamInput, Content_Length: String, preserveHTMLTags: Boolean): Response
  articleDocumentDeleteByQuery(Authorization: String, q: String): Response
  articleDocumentDelete(Authorization: String, documentIds: String): Response




  deleteStandaloneColorByLang(Authorization: String, lang: String): ColorResponse
  insertAsyncEvent(ESSAuthorization: String, X_InstanceId: String, body: param_insertAsyncEvent_bodyInput): DocumentTypeResponse
  insertAsyncEventObj(ESSAuthorization: String, X_InstanceId: String, body: SearchEventInput): DocumentTypeResponse
  insertEvent(body: param_insertEvent_bodyInput): DocumentTypeResponse
  validate(body: param_validate_bodyInput): EventValidationResponse
  helpDocumentUpload(Authorization: String, body: InputStreamInput, preserveHTMLTags: Boolean, Content_Length: String): Response
  helpDocumentDeleteByQuery(Authorization: String, q: String): Response
  helpDocumentDeleteById(Authorization: String, documentIds: String): Response


  createInstance(Authorization: String, body: NewInstanceRequestInput): InstanceResponse


  updateInstance(Authorization: String, instanceId: String, body: InstanceInput): SuccessResponse


  deleteInstance(Authorization: String, instanceId: String): SuccessResponse
  addAllFeeds(instanceId: String, feedId: String): InstanceResponse
  deleteAllFeeds(instanceId: String, feedId: String): InstanceResponse


  deleteFeed(instanceId: String, feedId: String): InstanceResponse
  setPreferences(instanceId: String, body: param_setPreferences_bodyInput): InstanceResponse


  createRanker(Authorization: String, instanceId: String, body: NewRankerRequestInput): InstanceResponse


  setCurrentRanker(instanceId: String, rankerId: String): InstanceResponse


  deleteRankerbyInstance(Authorization: String, instanceId: String, rankerId: String): InstanceResponse


  copyRanker(Authorization: String, instanceId: String, rankerId: String, newRankerName: String): InstanceResponse


  reindexInstance(instanceId: String, Authorization: String): InstanceResponse
  addScenario(instanceId: String, body: param_addScenario_bodyInput): InstanceResponse


  deleteScenario(Authorization: String, instanceId: String, scenarioId: String): InstanceResponse
  mediaDocumentUpload(Authorization: String, body: InputStreamInput, Content_Length: String, preserveHTMLTags: Boolean): Response
  mediaDocumentDeleteByQuery(Authorization: String, q: String): Response
  mediaDocumentDeleteById(Authorization: String, documentIds: String): Response
  createSearchMetric(ESSAuthorization: String, body: SearchMetricInput): createSearchMetric


  getMetricsWithSapphireSolrQuery(Authorization: String, instanceId: String, q: String, fq: [String], wt: String, facet: String, rows: Int, facet_field: [String], facet_limit: [String], facet_pivot: String, facet_missing: String, f_term_facet_sort: String, f_numResultsShown_facet_sort: String, facet_range: String, facet_range_start: String, facet_range_end: String, facet_range_gap: String): getMetricsWithSapphireSolrQuery
  productDocumentUpload(Authorization: String, body: InputStreamInput, Content_Length: String, preserveHTMLTags: Boolean): productDocumentUpload
  productDocumentDeleteByQuery(Authorization: String, q: String): Response
  productDocumentDelete(Authorization: String, documentIds: String): Response


  createCurrentRanker(Authorization: String, rankerId: String): SuccessResponse


  deleteRanker(Authorization: String, rankerId: String): SuccessResponse


  groundTruthDocumentUpload(Authorization: String, rows: String, rankerId: String, body: InputStreamInput): GroundTruthResponse


  postGroundTruthObservations(Authorization: String, rankerId: String, body: param_postGroundTruthObservations_bodyInput): GroundTruthResponse


  deleteSingleObservation(Authorization: String, rankerId: String, observationId: String): RankerResponse
  createRule(Authorization: String, orgId: String, body: RuleInput): UserResponse
  updateRule(Authorization: String, body: RuleInput): SuccessResponse
  deleteRule(Authorization: String): SuccessResponse
  serviceDocumentUpload(Authorization: String, body: InputStreamInput, Content_Length: String, preserveHTMLTags: Boolean): serviceDocumentUpload
  serviceDocumentDeleteByQuery(Authorization: String, q: String): Response
  serviceDocumentDelete(Authorization: String, documentIds: String): Response
  createSynonym(Authorization: String, permute: String, load: String, body: param_createSynonym_bodyInput): Response
  deleteSynonym(Authorization: String, synonym: String): SuccessResponse
  videosDocumentUpload(Authorization: String, body: InputStreamInput, Content_Length: String, preserveHTMLTags: Boolean): Response
  videoDocumentDeleteByQuery(Authorization: String, q: String): Response
  videoDocumentDeleteById(Authorization: String, documentIds: String): Response
}

input NewInstanceRequestInput {

  instanceName: String


  defaultSessionMaxAge: Int
}

input NewRankerRequestInput {
  rankerName: String
}

type OrgColor {
  id: String
  lang: String
  colors: [Color]
  modifiers: [String]
}

input param_addScenario_bodyInput {
  
  empty: String
}

input param_createSynonym_bodyInput {
  
  empty: String
}

input param_insertAsyncEvent_bodyInput {
  
  empty: String
}

input param_insertEvent_bodyInput {
  
  empty: String
}

input param_postGroundTruthObservations_bodyInput {
  
  empty: String
}

input param_saveStandaloneColors_bodyInput {
  
  empty: String
}

input param_setPreferences_bodyInput {
  
  empty: String
}

input param_validate_bodyInput {
  
  empty: String
}

type parameters_v1_rules_organization_orgId_rule_ruleId {
  
  empty: String
}

type preflight {
  
  empty: String
}

type preflight1 {
  
  empty: String
}

type preflight2 {
  
  empty: String
}

type Price {
  currency: String
  reg_price: Int
  current_price: Int
  sale_price: Int
  sale_start_date: String
  sale_end_date: String
  country: String
}

type Product {
     id: String
     title: String
     sku: String
     price : Price
     shortDescription: String
     longDescription: String
     brand: String
     categoryHierarchies : [CategoryHierarchy]
     thumbnails: [String]
     fullimage: [String]
     inventory: [Inventory]

}

type Inventory {
     productid: String
     storeid: String
     qtyonhand: Int
}

type Store {
     id: String
     name: String
     address: Address
     products: [Product]
}
 
type CategoryHierarchy {
     categories: [Category]
}

type Category {
     name: String
     id: String
}

type Order { 
     id: String
     confirmedDate:String
     paidDate:String
     lineitems: [LineItem]
     shipping: Int
     tax: Int
     discount: Int
     total:Int
     shippingAddress: Address
     billingAddress: Address
     status: String
}

type Shipment {
     id: String
     lineItems: [LineItem]
     order: Order
     shipped: String
     shippingAddress: Address
     received: String
     carrier: String
}

type LineItem {
     id: String 
     product: Product
     quantity: Int
     price: Price
     discount: Int
}

type Customer {
     id: String
     firstName: String
     lastName: String
     email: String
     phone: String
     billingAddress : Address
     shippingAddress : Address

}

type Address {
     id:String
     number: String
     street: String
     line2: String
     city: String
     state: String
     postal:String
     region: String
     country: String
     type: String
}

type productDocumentUpload {
  
  empty: String
}

type Query {
  getAllStandaloneColors(Authorization: String): ColorResponse
  getStandaloneColorByLang(Authorization: String, lang: String): ColorResponse


  getById(id: String): getById


  getInstancesForOrganization(Authorization: String): InstanceResponse


  getOrgColorByInstanceId(Authorization: String, instanceId: String): getOrgColorByInstanceId


  getCreateInstanceStatus(Authorization: String, instanceId: String): InstanceResponse


  getByInstanceId(Authorization: String, instanceId: String): InstanceResponse


  addFeed(instanceId: String, feedId: String): InstanceResponse


  getRankersForInstance(instanceId: String): InstanceResponse


  getCurrentRanker(instanceId: String): InstanceResponse


  getAggregationsBySearchTerms(Authorization: String): getAggregationsBySearchTerms


  getAggregationsForASearchTerm(Authorization: String, term: String): getAggregationsForASearchTerm
  getSearchEvents(Authorization: String): getSearchEvents
  getSearchEventsByTerm(Authorization: String, term: String): getSearchEventsByTerm


  getSchemaMetadataMockup(Authorization: String, instanceId: String): getSchemaMetadataMockup
  preflight1(instanceId: String, command: String): preflight1
  preflight2(instanceId: String, command: String, command2: String): preflight2
  resultClick(url: String, rank: String, start: String, nr: String, eak: String): resultClick


  getSearchTerms(Authorization: String): getSearchTerms


  listRankers(Authorization: String): RankerResponse


  statusRanker(Authorization: String, rankerId: String): RankerResponse


  getObservations(Authorization: String, rankerId: String): EditableGroundTruthObservationResponse


  getObservationsCSV(Authorization: String, rankerId: String): EditableGroundTruthObservationResponse


  getSingleObservation(Authorization: String, rankerId: String, observationId: String): GroundTruthObservation


  trainRanker(Authorization: String, rankerId: String): RankerResponse


  getAllRules(Authorization: String, orgId: String): RuleResponse


  getRulesActions(Authorization: String, orgId: String): RuleResponse


  getRulesConditions(Authorization: String, orgId: String): RuleResponse
  parameters_v1_rules_organization_orgId_rule_ruleId: parameters_v1_rules_organization_orgId_rule_ruleId
  getByRuleId(Authorization: String): RuleResponse


  getOrgRules(Authorization: String, orgId: String): RuleResponse
  reloadRulesEngine(Authorization: String): RuleResponse
  search(ESSAuthorization: String, q: String, start: String, rows: String, wt: String, json_wrf: String, ranker_id: String, solrformat: String, referrer_url: String, df: String, cts: String, customer_id: String, traceRules: Boolean, testModeRules: Boolean, language: String, locale: String, region: String, useRuleCache: String): SearchResponse
  preflight: preflight


  getIntent(Authorization: String, query: String): SemanticIntent


  getAllSynonyms(Authorization: String): RuleResponse


  getAllSynonymsCSV(Authorization: String): RuleResponse
  publishSynonyms(Authorization: String, reload: String): Response
  reloadCollection(Authorization: String, reload: String): Response


  getStatus(Authorization: String): RuleResponse
  getBySynonym(Authorization: String, synonym: String): RuleResponse
}

type QueryModification {
  id: String
  exclude: Boolean
  field: String
  value: String
  boost: String
}

input QueryModificationInput {
  id: String
  exclude: Boolean
  field: String
  value: String
  boost: String
}

type Ranker {
  id: String
  createdDate: String
  createdBy: LoggedUser
  lastModifiedDate: String
  lastModifiedBy: LoggedUser
  instance: Instance
  name: String
  groundTruthObservations: [GroundTruthObservation]
  status: String
  messages: [String]
  callbackUrl: String
  rerankingModelResourceUrl: String
  rankerSearchQueryParams: String
  rerankingModelId: String
  model: String
  entity: String
}

type RankerResponse {
  status: Int
  count: Int
  message: String
  rankers: [Ranker]
}

type Response {
  length: Int
  language: Locale
  location: String
  lastModified: String
  date: String
  headers: Response_headers
  allowedMethods: [String]
  metadata: Response_metadata
  statusInfo: StatusType
  status: Int
  cookies: Response_cookies
  entity: Response_entity
  mediaType: MediaType
  links: [Link]
  entityTag: EntityTag
  stringHeaders: Response_stringHeaders
}

type Response_cookies {
  
  empty: String
}

type Response_entity {
  
  empty: String
}

type Response_headers {
  
  empty: String
}

type Response_metadata {
  
  empty: String
}

type Response_stringHeaders {
  
  empty: String
}

type resultClick {
  
  empty: String
}


type Rule {
  id: String
  createdDate: String
  createdBy: LoggedUser
  lastModifiedDate: String
  lastModifiedBy: LoggedUser
  salience: Int
  name: String
  calendarFrom: String
  calendarTo: String
  global: Boolean
  enabled: Boolean
  orgId: String
  conditions: [RuleCondition]
  actions: [RuleAction]
  valid: Boolean
  active: Boolean
  entity: String
}

type RuleAction {
  name: String
  operator: String
  field: String
  value: String
  amount: Int
  prettyPrint: Boolean
  tab: String
}

input RuleActionInput {
  name: String
  operator: String
  field: String
  value: String
  amount: Int
  prettyPrint: Boolean
  tab: String
}

type RuleCondition {
  id: String
  createdDate: String
  createdBy: LoggedUser
  lastModifiedDate: String
  lastModifiedBy: LoggedUser
  global: Boolean
  bean: String
  field: String
  value: RuleCondition_value
  operator: String
  d: String
  entity: String
}

type RuleCondition_value {
  
  empty: String
}

input RuleCondition_valueInput {
  
  empty: String
}

input RuleConditionInput {
  id: String
  createdDate: String
  createdBy: LoggedUserInput
  lastModifiedDate: String
  lastModifiedBy: LoggedUserInput
  global: Boolean
  bean: String
  field: String
  value: RuleCondition_valueInput
  operator: String
  d: String
  entity: String
}

input RuleInput {
  id: String
  createdDate: String
  createdBy: LoggedUserInput
  lastModifiedDate: String
  lastModifiedBy: LoggedUserInput
  salience: Int
  name: String
  calendarFrom: String
  calendarTo: String
  global: Boolean
  enabled: Boolean
  orgId: String
  conditions: [RuleConditionInput]
  actions: [RuleActionInput]
  valid: Boolean
  active: Boolean
  entity: String
}

type RuleResponse {
  status: Int
  count: Int
  message: String
  rules: [Rule]
}

type SearchDocument {
  id: String
  docId: String
  brand: String
  document_type: String
  url: String
  description: Description
  media: [Medium]
  prices: [Price]
  keywords: [String]
  attributes: [Attribute]
  category: [String]
  content: String
  language: String
  location: [String]
}

input SearchEventAttributeInput {
  name: String
  value: String
}

input SearchEventInput {
  id: String
  createdDate: String
  createdBy: LoggedUserInput
  lastModifiedDate: String
  lastModifiedBy: LoggedUserInput
  attributes: [SearchEventAttributeInput]
  ssid: String
  eventCode: String
  timeStamp: String
  entity: String
}

input SearchMetricInput {
  id: String
  createdDate: String
  createdBy: LoggedUserInput
  lastModifiedDate: String
  lastModifiedBy: LoggedUserInput
  version: String
  searchApiKey: String
  instanceId: String
  instanceName: String
  term: String
  type: String
  searchSessionId: String
  searchUserCookie: String
  siteUserCookie: String
  url: String
  referrer: String
  searchableId: String
  searchDate: String
  numResultsShown: Int
  resultPositionClicked: Int
  startingResultShown: Int
  ipAddr: String
  count: Int
  entity: String
  customerId: String
}
type SearchMetric {
  id: String
  createdDate: String
  createdBy: LoggedUser
  lastModifiedDate: String
  lastModifiedBy: LoggedUser
  version: String
  searchApiKey: String
  instanceId: String
  instanceName: String
  term: String
  type: String
  searchSessionId: String
  searchUserCookie: String
  siteUserCookie: String
  url: String
  referrer: String
  searchableId: String
  searchDate: String
  numResultsShown: Int
  resultPositionClicked: Int
  startingResultShown: Int
  ipAddr: String
  count: Int
  entity: String
  customerId: String
}

type SearchResponse {
  numFound: Int
  start: Int
  searchResults: [SearchDocument]
  searchResultsNoRules: [SearchDocument]
  searchFacets: String
  searchNoRulesFacets: String
  ruleShapedSolrUrl: String
  ruleTrace: [String]
  ruleDuration: String
  redirectUrl: String
  semanticIntent: SemanticIntent
  trackingUrls: SearchResponse_trackingUrls
  trackingUrlsNoRules: SearchResponse_trackingUrlsNoRules
  duration: String
  color: OrgColor
  colorConfidence: [ColorDifference]
  dimensions: Dimensions
  equivalentDimensions: [LinearDimensions]
  mathResult: Int
  trackingSlug: String
  qtimeNoRules: String
  qtimeRules: String
}

type SearchResponse_trackingUrls {
  
  empty: String
}

type SearchResponse_trackingUrlsNoRules {
  
  empty: String
}

type SemanticIntent {
  topIntent: String
  intents: [ClassifierClass]
  success: Boolean
}

type serviceDocumentUpload {
  
  empty: String
}

type StatusType {
  statusCode: Int
  reasonPhrase: String
  family: String
}

type SuccessResponse {
  status: Int
  success: Boolean
  message: String
}

type UriBuilder {
 
  empty: String
}


type UserInstanceRole {
  instanceId: String
  role: String
}

type UserOrganizationRole {
  organizationId: String
  role: String
}

type UserResponse {
  status: Int
  count: Int
  message: String
  users: [User]
}

type Volume {
  value: Int
  units: String
}

type User {
  id: String
  createdDate: String
  createdBy: LoggedUser
  lastModifiedDate: String
  lastModifiedBy: LoggedUser
  blueId: String
  userName: String
  firstName: String
  lastName: String
  phoneNumber: String
  email: String
  division: String
  password: String
  instanceRoles: [UserInstanceRole]
  organizationRoles: [UserOrganizationRole]
  globalRoles: [String]
  isActive: Boolean
  name: String
  ibmadmin: Boolean
  entity: String
}

type RGB {
  r: Int
  b: Int
  g: Int
}

type Organization {
  id: String
  organizationAdminKey :String
  organizationName: String
  defaultSessionMaxAge: Int
  username  :String
  createdDate: String
  password  :String
  solrClusterId :String
  solrClusterName :String
  solrClusterStatus :String
  usingWatson : Boolean
  instances : [Instance]
  isActive :Boolean
  isRuleChanged: Boolean
}